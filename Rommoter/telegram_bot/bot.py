# telegram_bot/bot.py
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from config import config
from job_sources import fetch_all_jobs

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Extract relevant tags for jobs
def extract_tags(jobs) -> set:
    tags = set()
    for job in jobs:
        tags.update(tag.lower() for tag in job['tags'])
    return tags

# Step 1: Choose profession and experience level
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    professions = ['software engineer', 'data scientist', 'devops engineer', 'product manager']
    experience_levels = ['junior', 'middle', 'senior']
    
    profession_keyboard = [
        [InlineKeyboardButton(profession.title(), callback_data=f'profession_{profession}')] for profession in professions
    ]
    
    experience_keyboard = [
        [InlineKeyboardButton(level.title(), callback_data=f'level_{level}')] for level in experience_levels
    ]
    
    reply_markup_profession = InlineKeyboardMarkup(profession_keyboard)
    await update.message.reply_text('Select your profession:', reply_markup=reply_markup_profession)
    
    reply_markup_experience = InlineKeyboardMarkup(experience_keyboard)
    await update.message.reply_text('Select your experience level:', reply_markup=reply_markup_experience)

# Callback query handler for profession and experience level selection
async def profession_experience_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    selected_data = query.data
    if selected_data.startswith('profession_'):
        context.user_data['profession'] = selected_data.split('_')[1]
    elif selected_data.startswith('level_'):
        context.user_data['experience_level'] = selected_data.split('_')[1]
    
    if 'profession' in context.user_data and 'experience_level' in context.user_data:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"Selected Profession: {context.user_data['profession'].title()}\nSelected Experience Level: {context.user_data['experience_level'].title()}"
        )
        await ask_tag_generation_method(update, context)

# Step 2: Ask to autogenerate tags or enter tags manually
async def ask_tag_generation_method(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [
        [InlineKeyboardButton("Autogenerate Tags", callback_data='autogenerate_tags')],
        [InlineKeyboardButton("Enter Tags Manually", callback_data='manual_tags')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_message(chat_id=update.effective_chat.id, text='How would you like to enter tags?', reply_markup=reply_markup)

# Step 3: Generate/Grid Enter Tags
async def tag_generation_method(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    selected_data = query.data
    if selected_data == 'autogenerate_tags':
        await autogenerate_tags(update, context)
    elif selected_data == 'manual_tags':
        await manual_tag_entry(update, context)

async def autogenerate_tags(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Autogenerate tags based on profession and experience level (simple example)
    profession = context.user_data.get('profession', 'devops engineer')
    experience_level = context.user_data.get('experience_level', 'junior')
    
    autogenerated_tags = {
        'devops engineer': ['aws', 'docker', 'kubernetes', 'ci/cd', 'terraform', 'linux', 'jenkins', 'ansible'],
        'software engineer': ['python', 'javascript', 'react', 'node.js', 'java', 'c++', 'ruby', 'html/css'],
        'data scientist': ['python', 'pandas', 'machine learning', 'deep learning', 'tensorflow', 'numpy', 'statistics', 'r'],
        'product manager': ['agile', 'scrum', 'product roadmap', 'user stories', 'market research', 'ux/ui', 'business analysis']
    }
    
    selected_tags = autogenerated_tags.get(profession, [])
    context.user_data['selected_tags'] = set(selected_tags)
    context.user_data['jobs'] = fetch_all_jobs()  # Ensure jobs are fetched and stored
    
    await context.bot.send_message(chat_id=update.effective_chat.id, text=f"Autogenerated Tags: {', '.join(selected_tags)}")
    await display_start_search_button(update, context)

async def manual_tag_entry(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    jobs = fetch_all_jobs()
    tags = extract_tags(jobs)
    context.user_data['jobs'] = jobs
    context.user_data['selected_tags'] = set()

    keyboard = create_tag_keyboard(tags, context.user_data['selected_tags'])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_message(chat_id=update.effective_chat.id, text='Select tags to search for jobs:', reply_markup=reply_markup)

# Step 4: Start Searching
async def display_start_search_button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [[InlineKeyboardButton("Start Searching", callback_data='start_searching')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_message(chat_id=update.effective_chat.id, text='Press "Start Searching" to begin:', reply_markup=reply_markup)

async def start_searching(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    await search_jobs(update, context)

# Search jobs based on selected tags
async def search_jobs(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    selected_tags = context.user_data['selected_tags']
    jobs = context.user_data['jobs']
    matching_jobs = []

    for job in jobs:
        if 'tags' in job and selected_tags.intersection(set(job['tags'])):
            matching_jobs.append(job)

    if not matching_jobs:
        await update.callback_query.edit_message_text('No job postings found with the selected tags.')
        return

    for job in matching_jobs:
        message = (
            f"Title: {job.get('position', 'N/A')}\n"
            f"Company: {job.get('company', 'N/A')}\n"
            f"Location: {job.get('location', 'N/A')}\n"
            f"Link: {job.get('url', 'N/A')}"
        )
        await update.callback_query.message.reply_text(message)

# Create inline keyboard with tags in a grid layout
def create_tag_keyboard(tags, selected_tags):
    keyboard = []
    row = []
    for i, tag in enumerate(tags):
        if len(row) == 3:
            keyboard.append(row)
            row = []
        row.append(InlineKeyboardButton(f"{'âœ“ ' if tag in selected_tags else ''}{tag}", callback_data=tag))
    if row:
        keyboard.append(row)
    keyboard.append([InlineKeyboardButton("Start Searching", callback_data='start_searching')])
    return keyboard

def main() -> None:
    application = Application.builder().token(config.TELEGRAM_BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(profession_experience_selection, pattern='^(profession_|level_)'))
    application.add_handler(CallbackQueryHandler(tag_generation_method, pattern='^(autogenerate_tags|manual_tags)$'))
    application.add_handler(CallbackQueryHandler(start_searching, pattern='^start_searching$'))
    application.add_handler(CallbackQueryHandler(profession_experience_selection, pattern='^(?!start_searching|autogenerate_tags|manual_tags|profession_|level_).*'))

    application.run_polling()

if __name__ == '__main__':
    main()
